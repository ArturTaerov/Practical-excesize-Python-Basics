
# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора
# класса (метод __init__()), который должен принимать данные (список списков)
# для формирования матрицы.

# Подсказка: матрица — система некоторых математических величин, расположенных
# в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.

# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8

# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в
# привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции
# сложения двух объектов класса Matrix (двух матриц). Результатом сложения
# должна быть новая матрица.

# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент
# первой строки первой матрицы складываем с первым элементом первой строки
# второй матрицы и т.д.


class Matrix:
    
    def __init__(self, sp, j, f):
        self.sp = [sp[i] for i in range(len(sp))]
        self.sp2 = [sp2[i2] for i2 in range(len(sp2))]
        self.j = j
        self.f = f
            
    def __str__(self):
        return str(self.sp[j])
    
    def __add__(self, other):
        return  self.sp[self.j][self.f] + other.sp[self.j][self.f]
                         
sp = [[3, 5, 32], [2, 4, 6], [-1, 64, -8]]
sp2 = [[2, 7, 15], [32, 5, 72], [13, 8, 92]]

print("Сейчас будет выведена 1-я матрица:")
f = 0
for j in range(len(sp)):
    matr = Matrix(sp, j, f)
    print(matr)
    del matr

print("Сейчас будет выведена 2-я матрица:")
f = 0
for j in range(len(sp2)):
    matr = Matrix(sp2, j, f)
    print(matr)
    del matr

# определяем максимум количества столбцов
for k in range(len(sp)-1):
    maks = len(sp[0])
    if len(sp[k]) < len(sp[k+1]):
        maks = len(sp[k+1])

# складываем матрицы по элементно
print("Сейчас будет выведен результат сложения 2-х первых матриц:")
sp_it = [[None],[None],[None]]
for j in range(len(sp)):     
    for f in range(maks):
        matr = Matrix(sp, j, f)
        matr2 = Matrix(sp2, j, f)
        sp_it[j].append(matr + matr2)
        del matr, matr2
    sp_it[j].pop(0)
    print(sp_it[j])






#2. Реализовать проект расчёта суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь
# определённое название. К типам одежды в этом проекте относятся пальто и
# костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост
# (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы:
# для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих
# методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на
# этом уроке знания: реализовать абстрактные классы для основных классов
# проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod 

class Clothes(ABC):
    @abstractmethod
    def calc(self):
        pass

class Coat(Clothes):
    def __init__(self, size):
        self.size = size    
    @property
    def calc(self):
        return self.size/6.5 + 0.5

class Costume(Clothes):   
    def __init__(self, height):
        self.height = height       
    @property
    def calc(self):
        return 2*self.height + 0.3

ct = Coat(int(input("Введите количество пальто: ")))
cstm = Costume(int(input("Введите количество костюмов: ")))
print("Суммарный расход ткани на пошив всей одежды составил %.2f кв.м ткани"\
      % (ct.calc + cstm.calc))


    
    

#3. Реализовать программу работы с органическими клетками, состоящими из ячеек.
#Необходимо создать класс Клетка. В его конструкторе инициализировать параметр,
#соответствующий количеству ячеек клетки (целое число). В классе должны быть
#реализованы методы перегрузки арифметических операторов: сложение (__add__()),
#вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
#Данные методы должны применяться только к клеткам и выполнять увеличение,
#уменьшение, умножение и целочисленное (с округлением до целого) деление клеток
#, соответственно.

#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно
#равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если
#разность количества ячеек двух клеток больше нуля, иначе выводить
#соответствующее сообщение.
#Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки
#определяется как произведение количества ячеек этих двух клеток.
#Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется
#как целочисленное деление количества ячеек этих двух клеток.
#В классе необходимо реализовать метод make_order(), принимающий экземпляр
#класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки
#по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество
#ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда не
#хватает, то в последний ряд записываются все оставшиеся.

#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. 
#Тогда метод make_order() вернёт строку: *****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
#Тогда метод make_order() вернёт строку: *****\n*****\n*****.
#Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    def __init__(self, cage):
        self.cage = cage
        
    def __add__(self, other):
        return self.cage + other.cage
    
    def __sub__(self, other):
        if self.cage - other.cage > 0:
            x = self.cage - other.cage
        else:
            x = None
            print("Разность количества ячеек двух клеток меньше или равно" + \
                  " нуля!")
        return x    

    def __mul__(self, other):
        return self.cage * other.cage

    def __truediv__(self, other):
        try:
            x = self.cage // other.cage
        except other.cage == 0:
            x = None
            print("Количество ячеек клетки не должно быть равно нулю!")
        return x

    def make_order(self, row):
        sp = []
        for i in range(self.cage // row):
            sp.append("*" * row)
        sp.append("*" * (self.cage % row))        
        return "\n".join(sp)

cage1 = int(input("Введите количество ячеек клетки № 1: "))
cell1 = Cell(cage1)
cage2 = int(input("Введите количество ячеек клетки № 2: "))
cell2 = Cell(cage2)
print("Сумма клеток равна: ", cell1 + cell2)
print("Разность клетоки № 1 и клетки № 2 равна: ", cell1 - cell2)
print("Произведение клеток равно: ", cell1 * cell2)
print("Частное от деления клетоки № 1 на клетку № 2 равно: ", cell1 / cell2)
row = int(input("Введите количество ячеек (клеток) в ряду: "))
cage_row = Cell(cage1)
print(f"Упорядоченные ячейки клетки № 1: \n{cage_row.make_order(row)}")
cage_row = Cell(cage2)
print(f"Упорядоченные ячейки клетки № 2: \n{cage_row.make_order(row)}")